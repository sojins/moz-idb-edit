#!/usr/bin/python3
"""Access Mozilla IndexedDB database contents."""
# This Source Code Form is subject to the terms of the Mozilla Public
# License, v. 2.0. If a copy of the MPL was not distributed with this
# file, You can obtain one at http://mozilla.org/MPL/2.0/.
# Credits:
#   – Python source code by Alexander Schlarb, 2020.
#   - extended by mirabilos, 2023.

import argparse
import collections.abc
import json
import pathlib
import pprint
import re
import os
import shlex
import sys
import typing as ty

import jmespath
import mozidb

__dir__ = pathlib.Path(__file__).parent
__version__ = "0.1.0"


USER_CONTEXT_WEB_EXT = "userContextIdInternal.webextStorageLocal"


# Based on https://stackoverflow.com/a/24563687/277882
USER_PREF_RE = re.compile(rb"\s*user_pref\(([\"'])(.+?)\1,\s*(.+?)\);")
def read_user_prefs(prefs_path: os.PathLike):
    try:
        with open(prefs_path, "rb") as file:
            for line_no, line in enumerate(file, 1):
                m = USER_PREF_RE.match(line)
                if not m:
                    continue
                k, v = m.group(2), m.group(3)
                try:
                    k = k.decode("utf-8")
                    v = json.loads(v)
                except (ValueError, UnicodeDecodeError) as exc:
                    print(f"Failed to parse {prefs_path}:{line_no}: {type(exc).__name__}: {exc}", file=sys.stderr)
                else:
                    yield k, v
    except FileNotFoundError:
        pass


def read_user_contexts(profile_dir: pathlib.Path):
    try:
        with open(profile_dir / "containers.json", "rb") as file:
            data = json.load(file)

        assert data["version"] == 4

        for identity in data["identities"]:
            name = identity.get("name")
            if name is None:
                name = identity["l10nID"].split(".", 1)[0]
                if name.startswith("userContext"):
                    name = name[11:]

            yield int(identity["userContextId"]), name
    except (AssertionError, FileNotFoundError, ValueError) as exc:
        print(f"Failed to parse {profile_dir}/containers.json: {type(exc).__name__}: {exc}", file=sys.stderr)
        return 4294967295


def find_uuid_by_ext_id(profile_dir: pathlib.Path, ext_id: str) -> ty.Optional[str]:
    for name, value in read_user_prefs(profile_dir / "prefs.js"):
        if name == "extensions.webextensions.uuids":
            try:
                value = json.loads(value)
                return value.get(ext_id, None)
            except ValueError:
                pass


def find_context_id_by_name(profile_dir: pathlib.Path, name: str) -> int:
    for ctx_id, ctx_name in read_user_contexts(profile_dir):
        if ctx_name == name:
            return ctx_id

    if name == USER_CONTEXT_WEB_EXT:
        return 4294967295  # Default value (-1 as unsigned 32-value)
    else:
        raise KeyError(name)


class IDBObjectWrapper(collections.abc.Mapping):
    def __init__(self, conn: mozidb.IndexedDB):
        self._conn = conn

    def __getitem__(self, name: str) -> object:
        return self._conn.read_object(name)

    def __iter__(self) -> ty.Iterator[object]:
        yield from self._conn.list_objects()

    def __len__(self) -> int:
        return self._conn.count_objects()

    def __repr__(self) -> str:
        inner_repr = ", ".join(repr(k) + ": " + repr(v) for k, v in self.items())
        return f"{{{inner_repr}}}"

    def keys(self) -> ty.List[object]:
        return self._conn.list_objects()

    def items(self) -> ty.Iterable[ty.Tuple[object, object]]:
        return self._conn.read_objects().items()

    def values(self) -> ty.Iterable[object]:
        return self._conn.read_objects().values()


def _safe_repr(object, context, maxlevels, level, sort_dicts):
    """A repr function that returns more JSON-like output for primitive types

    Code copied from Python 3.9 stdlib pprint.py module.
    """
    typ = type(object)
    if typ in _builtin_scalars:
        # This is the actual patch: Use the JSON library to generate `repr` for
        # all primitive types
        return json.dumps(object, ensure_ascii=False), True, False

    r = getattr(typ, "__repr__", None)
    # Also allow our custom type to be treated as dict
    if issubclass(typ, (dict, IDBObjectWrapper)) and \
       r in (dict.__repr__, IDBObjectWrapper.__repr__):
        if not object:
            return "{}", True, False
        objid = id(object)
        if maxlevels and level >= maxlevels:
            return "{...}", False, objid in context
        if objid in context:
            return _recursion(object), False, True
        context[objid] = 1
        readable = True
        recursive = False
        components = []
        append = components.append
        level += 1
        if sort_dicts:
            items = sorted(object.items(), key=_safe_tuple)
        else:
            items = object.items()
        for k, v in items:
            krepr, kreadable, krecur = _safe_repr(k, context, maxlevels, level, sort_dicts)
            vrepr, vreadable, vrecur = _safe_repr(v, context, maxlevels, level, sort_dicts)
            append("%s: %s" % (krepr, vrepr))
            readable = readable and kreadable and vreadable
            if krecur or vrecur:
                recursive = True
        del context[objid]
        return "{%s}" % ", ".join(components), readable, recursive

    if (issubclass(typ, list) and r is list.__repr__) or \
       (issubclass(typ, tuple) and r is tuple.__repr__):
        if issubclass(typ, list):
            if not object:
                return "[]", True, False
            format = "[%s]"
        elif len(object) == 1:
            format = "(%s,)"
        else:
            if not object:
                return "()", True, False
            format = "(%s)"
        objid = id(object)
        if maxlevels and level >= maxlevels:
            return format % "...", False, objid in context
        if objid in context:
            return _recursion(object), False, True
        context[objid] = 1
        readable = True
        recursive = False
        components = []
        append = components.append
        level += 1
        for o in object:
            orepr, oreadable, orecur = _safe_repr(o, context, maxlevels, level, sort_dicts)
            append(orepr)
            if not oreadable:
                readable = False
            if orecur:
                recursive = True
        del context[objid]
        return format % ", ".join(components), readable, recursive

    rep = repr(object)
    return rep, (rep and not rep.startswith('<')), False

_builtin_scalars = frozenset({str, bytes, bytearray, int, float, complex,
                              bool, type(None)})

def _recursion(object):
    return ("<Recursion on %s with id=%s>"
            % (type(object).__name__, id(object)))

class _safe_key:
    """Helper function for key functions when sorting unorderable objects.

    The wrapped-object will fallback to a Py2.x style comparison for
    unorderable types (sorting first comparing the type name and then by
    the obj ids).  Does not work recursively, so dict.items() must have
    _safe_key applied to both the key and the value.
    """

    __slots__ = ['obj']

    def __init__(self, obj):
        self.obj = obj

    def __lt__(self, other):
        try:
            return self.obj < other.obj
        except TypeError:
            return ((str(type(self.obj)), id(self.obj)) < \
                    (str(type(other.obj)), id(other.obj)))

def _safe_tuple(t):
    "Helper function for comparing 2-tuples"
    return _safe_key(t[0]), _safe_key(t[1])


class PrettyPrinter(pprint.PrettyPrinter):
    def format(self, object, context, maxlevels, level):
        return _safe_repr(object, context, maxlevels, level, self._sort_dicts)

    # Break the maximum line length rules of pprint for strings (for which JSON
    # doesn't support the multiline string concatenation) and all other types
    # that were moded to have a non-default formatting to more closely align
    # with JSON
    _dispatch = pprint.PrettyPrinter._dispatch.copy()
    for tp in (str, bool):
        try:
            del _dispatch[tp.__repr__]
        except (AttributeError, KeyError):
            pass

    # Have our custom type be treated like a regular dict would
    _dispatch[IDBObjectWrapper.__repr__] = pprint.PrettyPrinter._pprint_dict


def getMozProfileOrDefault(parser, args):
    if args.profile:
        return
    homedir = pathlib.Path.home()
    mozdir = homedir.joinpath('.mozilla/firefox')
    from configparser import ConfigParser
    mozini = ConfigParser()
    mozini.read(mozdir.joinpath('profiles.ini'))
    for s in mozini.sections():
        if not s.startswith('Profile'):
            continue
        if 'path' not in mozini[s]:
            continue
        if 'default' not in mozini[s]:
            continue
        if mozini[s]['default'] == '1':
            args.profile = mozdir.joinpath(mozini[s]['path'])
            break
    if not args.profile:
        parser.error("Could not determine default Firefox profile, pass --profile")


def discover_idbs(sitebase):
    dbs = {}
    for db_path in sitebase.iterdir():
        if not db_path.name.endswith('.sqlite'):
            continue
        with mozidb.IndexedDB(db_path) as conn:
            db_name = conn.get_name()
            if db_name is not None:
                dbs[db_name] = db_path
    return dbs


def main(argv=sys.argv[1:], program=sys.argv[0]):
    parser = argparse.ArgumentParser(description=__doc__, prog=pathlib.Path(program).name)
    parser.add_argument("-V", "--version", action="version", version="%(prog)s {0}".format(__version__))
    parser.add_argument("-x", "--extension", action="store", metavar="EXT_ID",
                        help="Use database of the extension with the given Extension ID.")
    parser.add_argument("-s", "--site", action="store", metavar="SITE_NAME",
                        help="Use database of the site with the given name (- to list).")
    parser.add_argument("-S", "--sdb", action="store", metavar="DB_NAME",
                        help="Use database with the given name (omit to list) below a site.")
    parser.add_argument("--dbpath", action="store", metavar="DB_PATH", type=pathlib.Path,
                        help="Use database file with the the given path.")
    parser.add_argument("--userctx", action="store",
                        help="Use given user context (“Firefox container”) "
                             "when determining the database path.")
    parser.add_argument("-profile", "--profile", metavar="PROFILE", type=pathlib.Path,
                        help="Path to the Firefox/MozTK application profile directory.")
    parser.add_argument("key_name", metavar="KEY", default="@", nargs="?",
                        help="JMESPath of the key to query.")

    args = parser.parse_args(argv)

    if (int(bool(args.dbpath)) + int(bool(args.extension)) + int(bool(args.site))) != 1:
        parser.error("Exactly one of --dbpath, --extension or --site must be used")
        return 1

    if args.sdb and not args.site:
        parser.error("--sdb requires --site")

    ctx_id = 0  # Use default
    if args.userctx:
        try:
            ctx_id = int(args.userctx)
        except ValueError:
            ctx_id = find_context_id_by_name(args.profile_dir, args.userctx)


    # Collect required extra data for figuring out extension paths
    if args.extension:
        getMozProfileOrDefault(parser, args)

        # Map extension ID to browser internal UUID
        ext_uuid = find_uuid_by_ext_id(args.profile, args.extension)
        if ext_uuid is None:
            print(f"Failed to look up internal UUID for extension ID: {ext_id} (is the extension installed?)", file=sys.stderr)
            return 1

        # Use special extension storage ID if no other was set
        if args.userctx is None:
            ctx_id = find_context_id_by_name(args.profile, USER_CONTEXT_WEB_EXT)

        origin_label = f"moz-extension+++{ext_uuid}"
    if args.site:
        getMozProfileOrDefault(parser, args)
        storagebase = args.profile.joinpath('storage/default')
        # list sites?
        if args.site == '-':
            for site in sorted(map(lambda dir: dir.name,
                               filter(lambda dir: dir.name.startswith('http') and dir.joinpath('idb').exists(),
                                      storagebase.iterdir()))):
                print('--site', shlex.quote(site))
            sys.exit(0)
        sitebase = storagebase.joinpath(args.site).joinpath('idb')
        if not sitebase.exists():
            parser.error("Invalid --site given (pass --site - to list)")
        # list site databases?
        if not args.sdb:
            dbs = discover_idbs(sitebase)
            for db_name in sorted(dbs.keys()):
                print('--sdb', shlex.quote(db_name))
                print('--sdb', shlex.quote(dbs[db_name].name))
            sys.exit(0)
        args.dbpath = sitebase.joinpath(args.sdb)
        if not args.dbpath.exists():
            dbs = discover_idbs(sitebase)
            if args.sdb in dbs:
                args.dbpath = dbs[args.sdb]
        if not args.dbpath.exists():
            parser.error("Invalid --sdb given (omit --sdb with --site to list)")

    if args.dbpath:
        db_path = args.dbpath
    else:
        if ctx_id:
            origin_label += f"^userContextId={ctx_id}"

        db_path = args.profile / "storage" / "default" / origin_label
        db_path = db_path / "idb" / "3647222921wleabcEoxlt-eengsairo.sqlite"

    print(f"Using database path: {db_path}", file=sys.stderr)

    with mozidb.IndexedDB(db_path) as conn:
        pretty_printer = PrettyPrinter()
        pretty_printer.pprint(jmespath.search(args.key_name, IDBObjectWrapper(conn)))

    return 0


if __name__ == "__main__":
    sys.exit(main())
